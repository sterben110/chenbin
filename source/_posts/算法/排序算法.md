---
title: 排序算法
toc: true
date: 2020-07-25 14:41:06
categories: 算法
---
<meta name="referrer" content="no-referrer"/>

## 1、冒泡排序
> 对于一个数组，在每次循环中，遍历<font color=red>**剩余数组**</font>时，对比两个相邻的元素，前大后小则交换位置，遍历结束时<font color=red>**最大值**</font>就会冒泡排至最后面。然后缩短剩余数组继续遍历

如下图，剩余数组为【2,4,7,5,3】,每次比较相邻元素，大的交换至后面直至遍历结束，得到缩短后的剩余数组为【2,4,5,3】。<br />![](https://cdn.nlark.com/yuque/0/2020/svg/437282/1595657732836-ebfe8873-1bec-4287-87ac-3ade5db4047a.svg#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&originHeight=252&originWidth=362&size=0&status=done&style=none&width=215)
![](https://cdn.nlark.com/yuque/0/2020/svg/437282/1595657840279-46b935ac-c917-4e60-82e5-aa047d96b461.svg#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&originHeight=252&originWidth=362&size=0&status=done&style=none&width=215)
![](https://cdn.nlark.com/yuque/0/2020/svg/437282/1595657871852-06cae7a6-195c-42f5-90ae-a0972d9d8588.svg#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&originHeight=297&originWidth=362&size=0&status=done&style=none&width=183)
![](https://cdn.nlark.com/yuque/0/2020/svg/437282/1595657900975-7a13d800-a1ad-4f47-957a-f05e36c4a0d7.svg#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&originHeight=392&originWidth=371&size=0&status=done&style=none&width=237)
```java
// 冒泡排序(升序)
public static void bubbleSort(int[] array) {
    // 1. 每次循环，都能冒泡出剩余元素中最大的元素，因此需要循环 array.length 次
    for (int i = 0; i < array.length; i++) {
        // 2. 每次遍历，只需要遍历 0 到 array.length - i - 1中元素，因此之后的元素都已经是最大的了
        for (int j = 0; j < array.length - i - 1; j++) {
            //3. 交换元素
            if (array[j] > array[j + 1]) {
                int temp = array[j + 1];
                array[j + 1] = array[j];
                array[j] = temp;
            }
        }
    }
}
```

## 2、选择排序
> 重点在<font color=red>**选择**</font>，在每次循环中，遍历<font color=red>**剩余数组**</font>获取<font color=red>**最大值**</font>，放在数组最后。然后缩短剩余数组继续遍历

如下图，剩余数组为【3,2,4,7,5】，遍历该数组，得到最大值为 7 ,交换7、5（数组末尾元素），得到缩短后的剩余数组为【3,2,4,5】。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/437282/1595656929528-0fef4a12-0bde-48b7-b3f3-dd4a9a8a03b3.png#align=left&display=inline&height=140&margin=%5Bobject%20Object%5D&name=image.png&originHeight=140&originWidth=262&size=9238&status=done&style=none&width=262)
```java
  // 选择排序(升序)
  public static void selectSort(int[] array) {
    for (int i = 0; i < array.length; i++) {
      //最大值索引
      int maxIndex = 0;

      // 注意 j 从 索引1 开始，到 array.length - i 截止
      for (int j = 1; j < array.length - i; j++) {
        //若当前元素大于最大值，则替换最大值
        if (array[j] > array[maxIndex]) {
          maxIndex = j;
        }
      }

      // 交换最大值元素 和 数组末尾元素
      int temp = array[maxIndex];
      array[maxIndex] = array[array.length - i - 1];
      array[array.length - i - 1] = temp;
    }
  }
```
## 3、插入排序
时间复杂度徘徊在 `O(N)~O(N^2)` 
> 重点在<font color=red>**插入**</font>，在每次循环中，抽离出一个<font color=red>**临时元素**</font>，遍历临时元素的<font color=red>**右侧数组**</font>，寻找插入位置。

如下图，临时元素为4，遍历【3,5,7】数组寻找到插入位置为3、5之间，3左移一位，5、7不动。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/437282/1595656477902-26d815df-ba62-45fa-8e83-3ba86f22ca60.png#align=left&display=inline&height=88&margin=%5Bobject%20Object%5D&name=image.png&originHeight=91&originWidth=309&size=9491&status=done&style=none&width=300)
```java
  // 插入排序(升序)
  public static void insertSort(int[] array) {
    // 从倒数第二位开始，遍历到底0位，遍历 N-1 次
    for (int i = array.length - 2; i >= 0; i--) {
      // 存储当前抽离的临时元素
      int temp = array[i];
      
      int j;
      //遍历抽离元素的右侧数组，寻找插入位置
      for(j = i+1;j<array.length;j++){
          // 若临时元素大于当前元素，则这个元素左移
        if (array[j] < temp) {
          array[j - 1] = array[j];
        } else {
          // 如果临时元素小于当前元素，则将临时元素插入该元素之前，然后退出循环。
          array[j - 1] = temp;
          break;
        }
      }

      // 处理到达尾部的情况
      if (j == array.length) {
        array[j - 1] = temp;
      }
    }
  }
```
### 3.1、二分插入排序
> 与普通插入排序的区别在于，普通的插入排序在寻找4的插入位置采用的是<font color=red>**遍历数组**</font>，二分插入排序在寻找4的插入位置时用的是<font color=red>**二分查找法。**</font>

![image.png](https://cdn.nlark.com/yuque/0/2020/png/437282/1595656477902-26d815df-ba62-45fa-8e83-3ba86f22ca60.png#align=left&display=inline&height=88&margin=%5Bobject%20Object%5D&name=image.png&originHeight=91&originWidth=309&size=9491&status=done&style=none&width=300)<br />
```java
// 插入排序
public static void insertSort(int[] array) {
    // 从倒数第二位开始，遍历到底0位，遍历 N-1 次
    for (int i = array.length - 2; i >= 0; i--) {
        // 存储当前抽离的元素
        int temp = array[i];
        int index = searchIndex(array, i + 1, array.length - 1, temp);

        // #1. 根据插入的索引位置，进行数组的移动和插入
        int j = i + 1;
        while (j <= index) {
            array[j - 1] = array[j];
            j++;
        }
        array[j - 1] = temp;
    }
}
```
![](https://cdn.nlark.com/yuque/0/2020/svg/437282/1595658546381-4fc14a85-fc95-4b2c-9efe-2a1865430c58.svg#align=left&display=inline&height=301&margin=%5Bobject%20Object%5D&originHeight=301&originWidth=635&size=0&status=done&style=none&width=635)
```java
// 查找应该插入的索引位置
public static int searchIndex(int[] array, int left, int right, int aim) {
    // 循环查找节点位置
    while (left < right) {
        int middle = (left + right) / 2;
        int value = array[middle];
        if (value < aim) {
            left = middle + 1;
        } else {
            right = middle - 1;
        }
    }
    // #1. 如果最终元素仍然大于目标元素，则将索引位置往左边移动一个
    if(array[left] > aim){
        return left -1;
    }
    // 否则就是当前位置
    return left;
}
```
## 4、冒泡排序VS选择排序VS插入排序
> 冒泡排序相比较而言肯定是较差的。
> 选择排序和插入排序得分情况而定，如果<font color=red>**原始数组本身有很多元素按希望的顺序排好序**</font>，则选择<font color=red>**插入排序**</font>，否则选择<font color=red>**选择排序**</font>。

## 5、归并排序（递归）
时间复杂度为 `O(N*LogN)`
> 将大数组分解成小数组，将每个小数组排好序，再将这些有序的小数组合并成大数组。

<br />![](https://cdn.nlark.com/yuque/0/2020/svg/437282/1596010421927-2bc756e3-1a20-41ea-9687-8367ab7e5964.svg#align=left&display=inline&height=351&margin=%5Bobject%20Object%5D&originHeight=702&originWidth=782&size=0&status=done&style=none&width=391)<br />小数组合并<br />![](https://cdn.nlark.com/yuque/0/2020/svg/437282/1596010582073-f7a02079-90d5-41d9-a913-2253075a6faf.svg#align=left&display=inline&height=199&margin=%5Bobject%20Object%5D&originHeight=332&originWidth=501&size=0&status=done&style=none&width=300)
```java
 // 归并排序
  public static int[] mergeSort(int[] array) {
    // 为了方便查看结果，我们将每个数组进行打印
    if (array.length == 1) {
      return array;
    }

    int middle = array.length / 2;
    // 处理 0 到 middle 左侧数组部分
    int[] left = mergeSort(subArray(array, 0, middle));
    // 处理 middle 到 array.length 右侧数组部分
    int[] right = mergeSort(subArray(array, middle, array.length));

    //左侧数组指针
    int l = 0;
    //右侧数组指针
    int r = 0;
    int index = 0;
    while (l < left.length && r < right.length) {
      if (left[l] < right[r]) {
        array[index++] = left[l++];
      } else {
        array[index++] = right[r++];
      }
    }
    //左侧数组先遍历完时
    while (r < right.length) {
      array[index++] = right[r++];
    }
    //右侧数组先遍历完时
    while (l < left.length) {
      array[index++] = left[l++];
    }

    return array;
  }

  // 拷贝原数组的部分内容，从 left 到 right
  public static int[] subArray(int[] source, int left, int right) {
    // 创建一个新数组
    int[] result = new int[right - left];
    // 依次赋值进去
    for (int i = left; i < right; i++) {
      result[i - left] = source[i];
    }
    return result;
  }
```

## 6、快速排序（递归）
时间复杂度为 `O(N*LogN)~O(N^2)`<br />轴分区思想
> (1) 左指针依次往右侧移动，当遇到大于或者等于轴3的值，则停止
> (2) 右指针相反，依次往左侧移动，当遇到小于或者等于轴3的值，则停止
> (3) 将左右两个指针指向的值进行互换
> (4) 互换以后，然后继续按照上面（1）- （3）执行，直到左指针和右指针重叠。
> (5) 将左右两个指针指向的值和轴3互换

通过每次轴分区，都能完成轴的位置定位。<br />![](https://cdn.nlark.com/yuque/0/2020/svg/437282/1596011314151-8dda706c-affc-4cc0-8b69-37afe0d1a62e.svg#align=left&display=inline&height=241&margin=%5Bobject%20Object%5D&originHeight=241&originWidth=515&size=0&status=done&style=none&width=515)<br />![](https://cdn.nlark.com/yuque/0/2020/svg/437282/1596011570310-40af284b-af40-43e2-aac3-254eb80f772d.svg#align=left&display=inline&height=281&margin=%5Bobject%20Object%5D&originHeight=281&originWidth=352&size=0&status=done&style=none&width=352)<br />

```java
// 快速排序
  public static void quickSort(int[] array) {
    // 调用快速排序的核心，传入left，right
    quickSortCore(array, 0, array.length - 1);
  }

  // 快速排序的核心，同样也是递归函数
  public static void quickSortCore(int[] array, int left, int right) {
    // 递归基准条件，left >= right 即表示数组只有1个或者0个元素。
    if (left >= right) {
      return;
    }
    // 根据轴分区
    int pivotIndex = partition(array, left, right);

    // 递归调用左侧和右侧数组分区
    quickSortCore(array, left, pivotIndex - 1);
    quickSortCore(array, pivotIndex + 1, right);
  }

  // 对数组进行分区，并返回当前轴所在的位置
  public static int partition(int[] array, int left, int right) {
    //轴值，取数组末尾元素
    int value = array[right];

    //左右指针
    int leftIndex = left;
    int rightIndex = right - 1;

    while (true) {
      while (array[leftIndex] < value && leftIndex < right) {
        leftIndex++;
      }
      while (array[rightIndex] > value && rightIndex >= left) {
        rightIndex--;
      }

      if (leftIndex < rightIndex) {
        swap(array, leftIndex, rightIndex);
      } else {
        //左右指针重叠时
        break;
      }
    }

    swap(array, leftIndex, right);
    return leftIndex;
  }

  public static void swap(int[] array, int index1, int index2) {
    int temp = array[index1];
    array[index1] = array[index2];
    array[index2] = temp;
  }
```

